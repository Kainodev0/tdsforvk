import{VectorOps,RotationOps}from"../math";import{RawGenericJoint,RawJointAxis,RawJointType}from"../raw";export var JointType;!function(t){t[t.Revolute=0]="Revolute",t[t.Fixed=1]="Fixed",t[t.Prismatic=2]="Prismatic",t[t.Rope=3]="Rope",t[t.Spring=4]="Spring",t[t.Spherical=5]="Spherical",t[t.Generic=6]="Generic"}(JointType||(JointType={}));export var MotorModel;!function(t){t[t.AccelerationBased=0]="AccelerationBased",t[t.ForceBased=1]="ForceBased"}(MotorModel||(MotorModel={}));export var JointAxesMask;!function(t){t[t.LinX=1]="LinX",t[t.LinY=2]="LinY",t[t.LinZ=4]="LinZ",t[t.AngX=8]="AngX",t[t.AngY=16]="AngY",t[t.AngZ=32]="AngZ"}(JointAxesMask||(JointAxesMask={}));export class ImpulseJoint{constructor(t,e,i){this.rawSet=t,this.bodySet=e,this.handle=i}static newTyped(t,e,i){switch(t.jointType(i)){case RawJointType.Revolute:return new RevoluteImpulseJoint(t,e,i);case RawJointType.Prismatic:return new PrismaticImpulseJoint(t,e,i);case RawJointType.Fixed:return new FixedImpulseJoint(t,e,i);case RawJointType.Spring:return new SpringImpulseJoint(t,e,i);case RawJointType.Rope:return new RopeImpulseJoint(t,e,i);case RawJointType.Spherical:return new SphericalImpulseJoint(t,e,i);case RawJointType.Generic:return new GenericImpulseJoint(t,e,i);default:return new ImpulseJoint(t,e,i)}}finalizeDeserialization(t){this.bodySet=t}isValid(){return this.rawSet.contains(this.handle)}body1(){return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle))}body2(){return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle))}type(){return this.rawSet.jointType(this.handle)}frameX1(){return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle))}frameX2(){return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle))}anchor1(){return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle))}anchor2(){return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle))}setAnchor1(t){const e=VectorOps.intoRaw(t);this.rawSet.jointSetAnchor1(this.handle,e),e.free()}setAnchor2(t){const e=VectorOps.intoRaw(t);this.rawSet.jointSetAnchor2(this.handle,e),e.free()}setContactsEnabled(t){this.rawSet.jointSetContactsEnabled(this.handle,t)}contactsEnabled(){return this.rawSet.jointContactsEnabled(this.handle)}}export class UnitImpulseJoint extends ImpulseJoint{limitsEnabled(){return this.rawSet.jointLimitsEnabled(this.handle,this.rawAxis())}limitsMin(){return this.rawSet.jointLimitsMin(this.handle,this.rawAxis())}limitsMax(){return this.rawSet.jointLimitsMax(this.handle,this.rawAxis())}setLimits(t,e){this.rawSet.jointSetLimits(this.handle,this.rawAxis(),t,e)}configureMotorModel(t){this.rawSet.jointConfigureMotorModel(this.handle,this.rawAxis(),t)}configureMotorVelocity(t,e){this.rawSet.jointConfigureMotorVelocity(this.handle,this.rawAxis(),t,e)}configureMotorPosition(t,e,i){this.rawSet.jointConfigureMotorPosition(this.handle,this.rawAxis(),t,e,i)}configureMotor(t,e,i,n){this.rawSet.jointConfigureMotor(this.handle,this.rawAxis(),t,e,i,n)}}export class FixedImpulseJoint extends ImpulseJoint{}export class RopeImpulseJoint extends ImpulseJoint{}export class SpringImpulseJoint extends ImpulseJoint{}export class PrismaticImpulseJoint extends UnitImpulseJoint{rawAxis(){return RawJointAxis.LinX}}export class RevoluteImpulseJoint extends UnitImpulseJoint{rawAxis(){return RawJointAxis.AngX}}export class GenericImpulseJoint extends ImpulseJoint{}export class SphericalImpulseJoint extends ImpulseJoint{}export class JointData{constructor(){}static fixed(t,e,i,n){let o=new JointData;return o.anchor1=t,o.anchor2=i,o.frame1=e,o.frame2=n,o.jointType=JointType.Fixed,o}static spring(t,e,i,n,o){let r=new JointData;return r.anchor1=n,r.anchor2=o,r.length=t,r.stiffness=e,r.damping=i,r.jointType=JointType.Spring,r}static rope(t,e,i){let n=new JointData;return n.anchor1=e,n.anchor2=i,n.length=t,n.jointType=JointType.Rope,n}static generic(t,e,i,n){let o=new JointData;return o.anchor1=t,o.anchor2=e,o.axis=i,o.axesMask=n,o.jointType=JointType.Generic,o}static spherical(t,e){let i=new JointData;return i.anchor1=t,i.anchor2=e,i.jointType=JointType.Spherical,i}static prismatic(t,e,i){let n=new JointData;return n.anchor1=t,n.anchor2=e,n.axis=i,n.jointType=JointType.Prismatic,n}static revolute(t,e,i){let n=new JointData;return n.anchor1=t,n.anchor2=e,n.axis=i,n.jointType=JointType.Revolute,n}intoRaw(){let t,e,i=VectorOps.intoRaw(this.anchor1),n=VectorOps.intoRaw(this.anchor2),o=!1,r=0,s=0;switch(this.jointType){case JointType.Fixed:let a=RotationOps.intoRaw(this.frame1),h=RotationOps.intoRaw(this.frame2);e=RawGenericJoint.fixed(i,a,n,h),a.free(),h.free();break;case JointType.Spring:e=RawGenericJoint.spring(this.length,this.stiffness,this.damping,i,n);break;case JointType.Rope:e=RawGenericJoint.rope(this.length,i,n);break;case JointType.Prismatic:t=VectorOps.intoRaw(this.axis),this.limitsEnabled&&(o=!0,r=this.limits[0],s=this.limits[1]),e=RawGenericJoint.prismatic(i,n,t,o,r,s),t.free();break;case JointType.Generic:t=VectorOps.intoRaw(this.axis);let c=this.axesMask;e=RawGenericJoint.generic(i,n,t,c);break;case JointType.Spherical:e=RawGenericJoint.spherical(i,n);break;case JointType.Revolute:t=VectorOps.intoRaw(this.axis),e=RawGenericJoint.revolute(i,n,t),t.free()}return i.free(),n.free(),e}}