import{RawRigidBodySet}from"../raw";import{Coarena}from"../coarena";import{VectorOps,RotationOps}from"../math";import{RigidBody}from"./rigid_body";export class RigidBodySet{free(){this.raw&&this.raw.free(),this.raw=void 0,this.map&&this.map.clear(),this.map=void 0}constructor(a){this.raw=a||new RawRigidBodySet,this.map=new Coarena,a&&a.forEachRigidBodyHandle((t=>{this.map.set(t,new RigidBody(a,null,t))}))}finalizeDeserialization(a){this.map.forEach((t=>t.finalizeDeserialization(a)))}createRigidBody(a,t){let e=VectorOps.intoRaw(t.translation),i=RotationOps.intoRaw(t.rotation),r=VectorOps.intoRaw(t.linvel),o=VectorOps.intoRaw(t.centerOfMass),n=VectorOps.intoRaw(t.angvel),s=VectorOps.intoRaw(t.principalAngularInertia),l=RotationOps.intoRaw(t.angularInertiaLocalFrame),d=this.raw.createRigidBody(t.enabled,e,i,t.gravityScale,t.mass,t.massOnly,o,r,n,s,l,t.translationsEnabledX,t.translationsEnabledY,t.translationsEnabledZ,t.rotationsEnabledX,t.rotationsEnabledY,t.rotationsEnabledZ,t.linearDamping,t.angularDamping,t.status,t.canSleep,t.sleeping,t.softCcdPrediction,t.ccdEnabled,t.dominanceGroup,t.additionalSolverIterations);e.free(),i.free(),r.free(),o.free(),n.free(),s.free(),l.free();const c=new RigidBody(this.raw,a,d);return c.userData=t.userData,this.map.set(d,c),c}remove(a,t,e,i,r){for(let t=0;t<this.raw.rbNumColliders(a);t+=1)e.unmap(this.raw.rbCollider(a,t));i.forEachJointHandleAttachedToRigidBody(a,(a=>i.unmap(a))),r.forEachJointHandleAttachedToRigidBody(a,(a=>r.unmap(a))),this.raw.remove(a,t.raw,e.raw,i.raw,r.raw),this.map.delete(a)}len(){return this.map.len()}contains(a){return null!=this.get(a)}get(a){return this.map.get(a)}forEach(a){this.map.forEach(a)}forEachActiveRigidBody(a,t){a.forEachActiveRigidBodyHandle((a=>{t(this.get(a))}))}getAll(){return this.map.getAll()}}