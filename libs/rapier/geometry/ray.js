import{VectorOps}from"../math";import{FeatureType}from"./feature";export class Ray{constructor(t,e){this.origin=t,this.dir=e}pointAt(t){return{x:this.origin.x+this.dir.x*t,y:this.origin.y+this.dir.y*t,z:this.origin.z+this.dir.z*t}}}export class RayIntersection{constructor(t,e,r,i){this.featureType=FeatureType.Unknown,this.featureId=void 0,this.timeOfImpact=t,this.normal=e,void 0!==i&&(this.featureId=i),void 0!==r&&(this.featureType=r)}static fromRaw(t){if(!t)return null;const e=new RayIntersection(t.time_of_impact(),VectorOps.fromRaw(t.normal()),t.featureType(),t.featureId());return t.free(),e}}export class RayColliderIntersection{constructor(t,e,r,i,o){this.featureType=FeatureType.Unknown,this.featureId=void 0,this.collider=t,this.timeOfImpact=e,this.normal=r,void 0!==o&&(this.featureId=o),void 0!==i&&(this.featureType=i)}static fromRaw(t,e){if(!e)return null;const r=new RayColliderIntersection(t.get(e.colliderHandle()),e.time_of_impact(),VectorOps.fromRaw(e.normal()),e.featureType(),e.featureId());return e.free(),r}}export class RayColliderHit{constructor(t,e){this.collider=t,this.timeOfImpact=e}static fromRaw(t,e){if(!e)return null;const r=new RayColliderHit(t.get(e.colliderHandle()),e.timeOfImpact());return e.free(),r}}