import{RawColliderSet}from"../raw";import{Coarena}from"../coarena";import{RotationOps,VectorOps}from"../math";import{Collider}from"./collider";export class ColliderSet{free(){this.raw&&this.raw.free(),this.raw=void 0,this.map&&this.map.clear(),this.map=void 0}constructor(e){this.raw=e||new RawColliderSet,this.map=new Coarena,e&&e.forEachColliderHandle((e=>{this.map.set(e,new Collider(this,e,null))}))}castClosure(e){return t=>e?e(this.get(t)):void 0}finalizeDeserialization(e){this.map.forEach((t=>t.finalizeDeserialization(e)))}createCollider(e,t,r){let i=null!=r&&null!=r;if(i&&isNaN(r))throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");let a=t.shape.intoRaw(),o=VectorOps.intoRaw(t.translation),n=RotationOps.intoRaw(t.rotation),s=VectorOps.intoRaw(t.centerOfMass),l=VectorOps.intoRaw(t.principalAngularInertia),h=RotationOps.intoRaw(t.angularInertiaLocalFrame),p=this.raw.createCollider(t.enabled,a,o,n,t.massPropsMode,t.mass,s,l,h,t.density,t.friction,t.restitution,t.frictionCombineRule,t.restitutionCombineRule,t.isSensor,t.collisionGroups,t.solverGroups,t.activeCollisionTypes,t.activeHooks,t.activeEvents,t.contactForceEventThreshold,t.contactSkin,i,i?r:0,e.raw);a.free(),o.free(),n.free(),s.free(),l.free(),h.free();let c=i?e.get(r):null,m=new Collider(this,p,c,t.shape);return this.map.set(p,m),m}remove(e,t,r,i){this.raw.remove(e,t.raw,r.raw,i),this.unmap(e)}unmap(e){this.map.delete(e)}get(e){return this.map.get(e)}len(){return this.map.len()}contains(e){return null!=this.get(e)}forEach(e){this.map.forEach(e)}getAll(){return this.map.getAll()}}